import logging
from typing import Any, Dict, List, Optional, Protocol, Union, overload

Value = Union[str, bytes, int, float]


class Adapter(Protocol):
    async def execute(self, *args: Value) -> Any: ...
    async def eval(self, script: str, numkeys: int, *args) -> Any: ...
    async def delete(self, key: str) -> Any: ...
    async def expire(self, key: str, seconds: int) -> Any: ...
    async def keys(self, pattern: str) -> Any: ...
    async def get(self, key: str) -> Any: ...
    async def set(self, key: str, value: Any, *, ex: Optional[int] = None) -> Any: ...
    async def hget(self, key: str, field: str) -> Any: ...
    async def hdel(self, key: str, field: str) -> Any: ...
    async def hgetall(self, key: str) -> Any: ...
    @overload
    async def hset(self, key: str, field: str, value: Value): ...
    @overload
    async def hset(self, key: str, *, mapping: Dict[str, Value]): ...
    async def hmget(self, key: str, *fields: str) -> Any: ...
    async def rpush(self, key: str, value: Any) -> Any: ...
    async def blpop(self, *keys: str, timeout: float) -> Dict: ...
    async def lpop(self, key: str) -> Any: ...
    async def llen(self, key: str) -> int: ...
    async def lrem(self, key: str, count: int, element: Value): ...
    async def lrange(self, key: str, start: int, stop: int) -> Any: ...
    async def pfadd(self, key: str, *values) -> Any: ...
    async def pfmerge(self, key: str, *keys: str) -> Any: ...
    async def pfcount(self, key: str) -> Any: ...
    async def zadd(self, key: str, mapping: Dict[str, float]) -> Any: ...
    async def zrem(self, key: str, value: Any) -> Any: ...
    async def zcard(self, key: str) -> int: ...
    async def zrange(self, key: str, start: int, stop: int) -> Any: ...
    async def xadd(
        self,
        stream: str,
        items: Dict[str, Value],
        *,
        id: str = "*",
        mkstream: bool = True,
        maxlen: Optional[int] = None,
        minid: Optional[int] = None,
        approx: bool = True,
        limit: Optional[int] = None,
    ) -> str: ...
    async def xread(
        self,
        *streams: str,
        id: str,
        block: Optional[int] = None,
        count: Optional[int] = None,
        noack: Optional[bool] = None,
        group: Optional[str] = None,
    ) -> Dict: ...


class AdapterHolder(Protocol):
    client: Any

    def __init__(
        self,
        logger: Optional[logging.Logger] = None,
    ): ...
    async def __aenter__(
        self,
        address: Union[str, List[str], List[List[str]]] = "redis://localhost:6379",
        db: Optional[int] = None,
        min_size: Optional[int] = None,
        max_size: Optional[int] = None,
        cluster: Optional[bool] = None,
        username: Optional[str] = None,
        password: Optional[str] = None,
        client_id: Optional[str] = None,
        format: Optional[str] = None,
        logger: Optional[logging.Logger] = None,
        **kwargs,
    ) -> Adapter: ...
    async def __aexit__(self, exc_type, exc_val, exc_tb): ...
